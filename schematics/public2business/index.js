'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var core = require('@angular-devkit/core');
var schematics = require('@angular-devkit/schematics');
var child_process = require('child_process');
var crypto = require('crypto');
var fs = require('fs');
var os = require('os');
var path = require('path');

const { getNativeBinary } = require('@bazel/buildifier/buildifier');
const buildifierArguments = parseBuildifierArguments();
function parseBuildifierArguments() {
    const pckg = require('../../package.json');
    const script = pckg.scripts['bazel:buildifier'];
    if (!script) {
        throw new schematics.SchematicsException('Could not find script bazel:buildifier in package.json');
    }
    const args = script.split('xargs buildifier -v')[1];
    if (!args) {
        throw new schematics.SchematicsException('Could not find `xargs buildifier -v` in bazel:buildifier in package.json');
    }
    return `${args} --lint=fix --mode=fix`;
}
function formatBazelFile(relativePath, content) {
    const tmpPath = path.join(os.tmpdir(), `bazel_file_to_format_${crypto.randomBytes(32).toString('hex')}.bazel`);
    fs.writeFileSync(tmpPath, content, 'utf8');
    const binary = getNativeBinary();
    child_process.execSync(`"${binary}" ${buildifierArguments} -path=${relativePath} "${tmpPath}"`);
    const result = fs.readFileSync(tmpPath, 'utf8');
    fs.unlinkSync(tmpPath);
    return result;
}

const AUTOGENERATED_FILES = {
    AUTOGENERATED_DO_NOT_MODIFY: 'See schematics/public2business',
    '.gitignore': '*',
};
const MODULES = [
    'accordion',
    'autocomplete',
    'badge',
    'breadcrumb',
    'datepicker',
    'dropdown',
    'field',
    'form-field',
    'file-selector',
    'input',
    'loading',
    'option',
    'pagination',
    'radio-button',
    'select',
    'tabs',
    'textarea',
    'textexpand',
    'time-input',
    'usermenu',
];
function public2business(options) {
    return (tree) => {
        MODULES.filter((m) => !options || !options.filter || m === options.filter).forEach((m) => copyAndAdaptPublicModule(m));
        function copyAndAdaptPublicModule(moduleName) {
            const publicDir = tree.getDir(`src/angular-public/${moduleName}`);
            const businessDir = tree.getDir(`src/angular-business/${moduleName}`);
            // Clear deleted files
            businessDir.visit((path) => {
                if (path.endsWith('.spec.ts') ||
                    (Object.keys(AUTOGENERATED_FILES).every((k) => !path.endsWith(k)) &&
                        !tree.exists(core.join(publicDir.path, core.relative(businessDir.path, path))))) {
                    tree.delete(path);
                }
            });
            publicDir.visit((path, entry) => {
                if (entry && !path.endsWith('.spec.ts')) {
                    let targetPath = core.join(businessDir.path, core.relative(publicDir.path, path));
                    if (targetPath.endsWith('.business.html')) {
                        targetPath = targetPath.replace('.business.html', '.html');
                    }
                    const content = adaptFile(entry);
                    if (hasBusinessVariant(path)) ;
                    else if (!tree.exists(targetPath)) {
                        tree.create(targetPath, content);
                    }
                    else if (tree.read(targetPath).toString() !== content) {
                        tree.overwrite(targetPath, content);
                    }
                }
            });
            Object.entries(AUTOGENERATED_FILES).forEach(([name, content]) => {
                const filePath = core.join(businessDir.path, name);
                if (!tree.exists(filePath)) {
                    tree.create(filePath, content);
                }
            });
        }
        function hasBusinessVariant(path) {
            return (path.endsWith('component.html') && tree.exists(path.replace('.html', '.business.html')));
        }
        function adaptFile(entry) {
            const autogenerated = '/** Autogenerated by public2business schematic. DO NOT CHANGE! */\n';
            const content = entry.content.toString('utf8');
            if (['md', 'json', 'html'].some((e) => entry.path.endsWith(`.${e}`))) {
                return content;
            }
            else if (entry.path.endsWith('.scss')) {
                return `${autogenerated}$sbbBusiness: true;\n\n${content}`;
            }
            else if (entry.path.endsWith('.ts')) {
                return `${autogenerated}/* tslint:disable */\n${content}`.replace(/@sbb-esta\/angular-public/g, '@sbb-esta/angular-business');
            }
            else if (entry.path.endsWith('.bazel')) {
                const file = `# Autogenerated by public2business schematic. DO NOT CHANGE!\n${content}`
                    .replace(/public\//g, 'business/')
                    .replace(/    "ng_test_library",\n/g, '')
                    .replace(/    "ng_web_test_suite",\n/g, '')
                    .replace(/deps = \[\n([ ]+)(("[^"]+",\n[ ]+){2,})\]/gm, (_f, space, deps) => {
                    let newDeps = 'deps = [\n';
                    deps
                        .match(/("[^"]+")/g)
                        .sort()
                        .forEach((d) => (newDeps += `${space}${d},\n`));
                    return `${newDeps}${space.substring(4)}]`;
                })
                    .replace(/\nng_test_library\([\w\W]+?ng_web_test_suite\([\w\W]+?(\r\n|\r|\n)\)\n/m, '');
                return formatBazelFile(core.relative(tree.root.path, entry.path), file);
            }
            else {
                return `${autogenerated}${content}`;
            }
        }
    };
}

exports.MODULES = MODULES;
exports.public2business = public2business;
